<#
.SYNOPSIS
    Hybrid file encryption using AES (for data) and RSA (for the AES key), keyed by a password.

.DESCRIPTION
    This script encrypts or decrypts a file using a hybrid AES/RSA scheme. On encryption, it:
      1. Checks that the input file exists.
      2. Generates a new random AES key (256-bit) and IV; encrypts the file data with AES/CBC1213.
      3. Generates a new RSA 2048-bit key pair14. Encrypts the AES key with the RSA public key (OAEP padding)15.
      4. Derives an encryption key from the password (using PBKDF2 + random salt) and uses it to AES-encrypt the RSA private key16.
      5. Writes an output file containing all components: a magic header, the salt and IV for the password, the encrypted RSA private key, the encrypted AES key, the IV for file encryption, and the AES-encrypted data.
    On decryption, it reverses the process:
      1. Reads and verifies the header, extracts salt, IV, encrypted RSA key, encrypted AES key, file IV, and data.
      2. Derives the AES key from the password (same salt) to decrypt the RSA private key.
      3. Uses the RSA private key to decrypt the AES key.
      4. Uses the AES key and IV to decrypt the file data.
    Usage:
      To encrypt: `.\EncryptDecryptFile.ps1 <FilePath> <Password>`
      This outputs `<FilePath>.aes`. 
      To decrypt: `.\EncryptDecryptFile.ps1 <FilePath>.aes <Password>`
      This restores the original `<FilePath>`.
#>

param(
    [Parameter(Mandatory=$true, Position=0)]
    [string]$FilePath,
    [Parameter(Mandatory=$true, Position=1)]
    [string]$Password
)

# Check that the file exists
if (-not (Test-Path $FilePath -PathType Leaf)) {
    Write-Error "File not found: $FilePath"
    exit 1
}

# Decide mode based on file extension (.aes or .enc for encrypted)
$ext = [System.IO.Path]::GetExtension($FilePath).ToLower()
$encryptMode = ($ext -ne ".aes" -and $ext -ne ".enc")

try {
    if ($encryptMode) {
        # --- ENCRYPTION PATH ---
        # Read the original file bytes
        $plainBytes = [System.IO.File]::ReadAllBytes($FilePath)

        # Generate AES key and IV for data encryption (256-bit key)
        $aes = [System.Security.Cryptography.Aes]::Create()
        $aes.KeySize = 256
        $aes.GenerateKey()
        $aes.GenerateIV()
        $aesKey = $aes.Key
        $aesIV  = $aes.IV

        # Encrypt the file data with AES (CBC mode)
        $encryptor = $aes.CreateEncryptor($aesKey, $aesIV)
        $encryptedData = $encryptor.TransformFinalBlock($plainBytes, 0, $plainBytes.Length)

        # Generate RSA key pair (2048 bits)
        $rsa = New-Object System.Security.Cryptography.RSACryptoServiceProvider(2048)
        $rsaKeyXml = $rsa.ToXmlString($true)  # XML of private+public key

        # Encrypt the AES key with RSA public key (using OAEP padding)
        $encryptedAesKey = $rsa.Encrypt($aesKey, $true)

        # Derive a key from the password to protect the RSA private key
        $salt = New-Object byte[](16)
        [Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($salt)
        $kdf = New-Object System.Security.Cryptography.Rfc2898DeriveBytes($Password, $salt, 10000)
        $keyForPriv = $kdf.GetBytes(32)  # 256-bit key for AES
        # Use a random IV for encrypting the private key
        $ivPriv = New-Object byte[]($aes.BlockSize/8)
        [Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($ivPriv)
        $aesPriv = [System.Security.Cryptography.Aes]::Create()
        $aesPriv.Key = $keyForPriv
        $aesPriv.IV  = $ivPriv

        # Encrypt the RSA private key XML string
        $privBytes = [System.Text.Encoding]::UTF8.GetBytes($rsaKeyXml)
        $privEncryptor = $aesPriv.CreateEncryptor($keyForPriv, $ivPriv)
        $encryptedPrivKey = $privEncryptor.TransformFinalBlock($privBytes, 0, $privBytes.Length)

        # Prepare output: magic header, then lengths and pieces
        $header = [System.Text.Encoding]::UTF8.GetBytes("PSAESENC")  # 8-byte magic
        $outBytes = New-Object System.Collections.Generic.List[byte]
        $outBytes.AddRange($header)
        # Salt for PBKDF2
        $outBytes.AddRange([BitConverter]::GetBytes($salt.Length)); $outBytes.AddRange($salt)
        # IV for private-key encryption
        $outBytes.AddRange([BitConverter]::GetBytes($ivPriv.Length)); $outBytes.AddRange($ivPriv)
        # Encrypted RSA private key
        $outBytes.AddRange([BitConverter]::GetBytes($encryptedPrivKey.Length)); $outBytes.AddRange($encryptedPrivKey)
        # Encrypted AES key
        $outBytes.AddRange([BitConverter]::GetBytes($encryptedAesKey.Length)); $outBytes.AddRange($encryptedAesKey)
        # IV for data encryption
        $outBytes.AddRange([BitConverter]::GetBytes($aesIV.Length)); $outBytes.AddRange($aesIV)
        # Encrypted file data
        $outBytes.AddRange([BitConverter]::GetBytes($encryptedData.Length)); $outBytes.AddRange($encryptedData)

        # Write to output file with .aes extension
        $outFile = $FilePath + ".aes"
        if (Test-Path $outFile) {
            Write-Error "Output file already exists: $outFile"
            exit 1
        }
        [System.IO.File]::WriteAllBytes($outFile, $outBytes.ToArray())
        Write-Host "Encryption complete. Output file: $outFile"
    }
    else {
        # --- DECRYPTION PATH ---
        # Read all bytes from the encrypted file
        $allBytes = [System.IO.File]::ReadAllBytes($FilePath)

        # Verify header
        $headerStr = [System.Text.Encoding]::UTF8.GetString($allBytes, 0, 8)
        if ($headerStr -ne "PSAESENC") {
            Write-Error "File is not in expected encrypted format."
            exit 1
        }

        $offset = 8
        # Helper: read Int32 and advance offset
        function ReadInt32 {
            param([byte[]]$bytes, [ref]$idx)
            $val = [BitConverter]::ToInt32($bytes, $idx.Value)
            $idx.Value += 4
            return $val
        }

        # Extract salt
        $saltLen = ReadInt32 -bytes $allBytes -idx ([ref]$offset)
        $salt = $allBytes[$offset..($offset + $saltLen - 1)]
        $offset += $saltLen

        # Extract IV for private-key encryption
        $ivPrivLen = ReadInt32 -bytes $allBytes -idx ([ref]$offset)
        $ivPriv = $allBytes[$offset..($offset + $ivPrivLen - 1)]
        $offset += $ivPrivLen

        # Extract encrypted RSA private key
        $encPrivLen = ReadInt32 -bytes $allBytes -idx ([ref]$offset)
        $encPriv = $allBytes[$offset..($offset + $encPrivLen - 1)]
        $offset += $encPrivLen

        # Extract encrypted AES key
        $encAesKeyLen = ReadInt32 -bytes $allBytes -idx ([ref]$offset)
        $encAesKey = $allBytes[$offset..($offset + $encAesKeyLen - 1)]
        $offset += $encAesKeyLen

        # Extract IV for data
        $ivDataLen = ReadInt32 -bytes $allBytes -idx ([ref]$offset)
        $aesIV = $allBytes[$offset..($offset + $ivDataLen - 1)]
        $offset += $ivDataLen

        # Extract encrypted file data
        $dataLen = ReadInt32 -bytes $allBytes -idx ([ref]$offset)
        $encData = $allBytes[$offset..($offset + $dataLen - 1)]
        # offset += $dataLen  (not needed beyond this)

        # Derive AES key from password to decrypt RSA private key
        $kdf = New-Object System.Security.Cryptography.Rfc2898DeriveBytes($Password, $salt, 10000)
        $keyForPriv = $kdf.GetBytes(32)
        $aesPriv = [System.Security.Cryptography.Aes]::Create()
        $aesPriv.Key = $keyForPriv
        $aesPriv.IV  = $ivPriv
        $decPriv = $aesPriv.CreateDecryptor($keyForPriv, $ivPriv).TransformFinalBlock($encPriv, 0, $encPriv.Length)
        $rsaKeyXml = [System.Text.Encoding]::UTF8.GetString($decPriv)

        # Load RSA key
        $rsa = New-Object System.Security.Cryptography.RSACryptoServiceProvider
        $rsa.FromXmlString($rsaKeyXml)

        # Decrypt the AES key with the RSA private key (OAEP padding)
        $aesKey = $rsa.Decrypt($encAesKey, $true)

        # Decrypt the file data using AES key/IV
        $aes2 = [System.Security.Cryptography.Aes]::Create()
        $aes2.Key = $aesKey
        $aes2.IV  = $aesIV
        $decryptedData = $aes2.CreateDecryptor().TransformFinalBlock($encData, 0, $encData.Length)

        # Write the decrypted data to output file (remove .aes/.enc suffix)
        $dir  = [System.IO.Path]::GetDirectoryName($FilePath)
        $base = [System.IO.Path]::GetFileNameWithoutExtension($FilePath)
        $outFile = if ($dir) { Join-Path $dir $base } else { $base }
        if (Test-Path $outFile) {
            Write-Error "Output file already exists: $outFile"
            exit 1
        }
        [System.IO.File]::WriteAllBytes($outFile, $decryptedData)
        Write-Host "Decryption complete. Output file: $outFile"
    }
}
catch {
    Write-Error "An error occurred: $_"
    exit 1
}